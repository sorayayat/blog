# 개요
글을 시작하기에 앞서, 마치 책의 앞장에 있는 서론처럼, 소프트웨어 디자인 패턴에 대해 간단히 설명하고자 합니다.

### 디자인 패턴이란?

소프트웨어 공학에서 디자인 패턴은 자주 발생하는 문제에 대해 재사용 가능한 해결책입니다. 말하자면, 누군가 이미 많은 시행착오를 겪고 나서 특정 문제나 상황에 맞는 최적의 해결책을 만들어 둔 것이죠.

하지만 "디자인 패턴을 적용하면 모든 문제가 사라지겠지!"라는 생각은 하지 않으리라 믿습니다. 패턴은 문제 해결의 실마리와 효율적인 구조를 제공할 뿐, 모든 상황을 완벽하게 해결해주는 만능 열쇠는 아닙니다.

### 왜 배워야 하는가?

객체 지향 프로그래밍(OOP)은 매우 멋진 개념이지만, 그 구조가 복잡할 수 있습니다. (네, 저에게도 매우 복잡합니다.) 다양한 상황에서 마주치는 문제를 해결하는 데 있어서 디자인 패턴은 매우 유용한 가이드라인을 제공할 수 있습니다.

또한, 디자인 패턴은 **재사용 가능한** 해결책을 제시합니다. 게다가 팀 내 모든 개발자가 동일한 디자인 패턴을 알고 있다면 복잡한 설명을 생략하고, 패턴의 이름만으로도 빠르게 의사소통할 수 있습니다. 예를 들어, “이 부분은 전략 패턴(Strategy Pattern)을 사용해서 구현했어.”라고 설명한다면, 팀원들은 해당 구조를 쉽게 이해할 수 있습니다.

저도 한 번은 동료 개발자가 “**옵저버 패턴**을 적용해보는 건 어떨까요?”라고 말했을 때, 제가 “그게 뭐죠?”라고 되물어본 적이 있습니다. 그리고 그 후 30분간의 긴 미팅을 경험하게 되었죠. 그렇기에, 하나씩 이해하고 익혀보는 것이 중요합니다.

하지만 모든 디자인 패턴을 다 알아야 할 필요는 없습니다. 여러분이 겪고 있는 문제를 생각하며 어떤 패턴이 필요한지 고민해 보시기 바랍니다.

---

# 디자인 패턴 시리즈 - 1편 (전략 패턴, Strategy Pattern)

상황을 가정해 봅시다. 당신은 바닷 속 물고기들이 등장 하는 게임을 만들고 있다고 가정해 봅시다.

```java
public abstract class Fish {

    public abstract void swim();

    public abstract void breathing(); // 추가된 메소드
}
```

위와 같이 `Fish`라는 추상 클래스를 만들고, 물고기들의 수영 방식과 호흡 방식을 정의하는 메소드를 추가한다고 생각 해봅시다.

문제는 신규 캐릭터(예: 고래 종류)가 등장하면서 발생합니다. 고래는 수면 위로 올라와서 호흡을 해야 하는데, 기존의 물고기들은 아가미로 호흡하는 방식이었습니다. 그렇다면 고래의 호흡 방식을 구현하려고 모든 물고기 클래스에 메소드를 오버 라이드 해야 할 것입니다. 하지만 이렇게 하다 보면, 모든 코드를 수정해야 하는 상황이 발생할 수 있습니다.

또 다른 문제는 문어나 오징어 같은 캐릭터를 추가하면서 발생할 수 있습니다. 문어와 오징어는 먹물을 뿜는 기능이 필요하죠. 이를 위해 새로운 메소드를 추가한다면, 또다시 모든 물고기 클래스에 영향을 미치게 됩니다.

이때 중요한 사실은, **프로그램에서 변화는 불변의 법칙이다**는 것입니다. 즉, 프로그램의 요구사항은 언제든 변할 수 있고, 우리는 그 변화를 효과적으로 대응할 수 있어야 합니다.

## 전략 패턴의 필요성

변화하는 것과 변하지 않는 것을 분리해야 합니다. 수영 방식이나 호흡 방식은 변할 수 있지만, 그와 무관한 다른 동작은 변하지 않을 수 있습니다. 이런 변화를 관리하기 위해 **전략 패턴**을 사용할 수 있습니다.

전략 패턴에서는 동작을 캡슐화하고, 이를 인터페이스를 통해 정의합니다. 이 방식은 행동을 유연하게 바꿀 수 있도록 도와줍니다. 다음은 전략 패턴을 적용한 예시입니다.

### 인터페이스 정의

우선, 수영하는 방식을 인터페이스로 정의합니다.

```java
interface Swim {
    String getSwimMessage();
}
```

### 구체적인 구현

그리고 각각의 전략적 분류를 통해 구현체를 만듭니다.

```java
class FishSwim implements Swim {
    public String getSwimMessage() {
        return "꼬리를 흔들며 헤엄친다!!";
    }
}

class ShellfishSwim implements Swim {
    public String getSwimMessage() {
        return "가만히 바위에 붙어있는다..";
    }
}
```

이제 `Fish` 클래스에서 수영 방식에 대한 동작을 직접 구현하지 않고, 위에서 정의한 인터페이스를 통해 동작을 설정합니다.

```java
class Fish {
    private Swim swimBehavior;

    public Fish(Swim swimBehavior) {
        this.swimBehavior = swimBehavior;
    }

    public void performSwim() {
        System.out.println(swimBehavior.getSwimMessage());
    }

    // 다른 메소드들...
}
```

### 사용 예시

마지막으로, 고래와 조개 같은 캐릭터에 따라 적절한 수영 동작을 설정할 수 있습니다.

```java
public class Main {
    public static void main(String[] args) {
        Fish whale = new Fish(new FishSwim());
        Fish shellfish = new Fish(new ShellfishSwim());

        whale.performSwim(); // "꼬리를 흔들며 헤엄친다!!"
        shellfish.performSwim(); // "가만히 바위에 붙어있는다.."
    }
}
```

이렇게 함으로써, 새로운 캐릭터가 추가되거나 동작이 변화해야 할 때, 코드의 다른 부분을 건드리지 않고도 새로운 전략을 추가하거나 수정할 수 있습니다.

## 결론

**전략 패턴**은 행동을 유연하게 변경할 수 있도록 돕는 강력한 도구입니다. 변화를 최소화하면서도 새로운 요구사항에 쉽게 대응할 수 있도록 해줍니다. 이처럼 디자인 패턴은 복잡한 객체 지향 설계에서 가이드를 제공하고, 유지보수를 용이하게 하며, 코드의 재사용성을 극대화합니다.

다음 편에서는 또 다른 디자인 패턴을 살펴보며, 다양한 상황에서 어떻게 적용할 수 있을지 알아보겠습니다.

> 헤드 퍼스트 디자인 패턴 - 에릭 프리먼, 엘리자베스 롭슨, 케이시 시에라, 버트 베이츠 저자 [https://hudi.blog/strategy-pattern/](https://hudi.blog/strategy-pattern/) - 후디님의 블로그